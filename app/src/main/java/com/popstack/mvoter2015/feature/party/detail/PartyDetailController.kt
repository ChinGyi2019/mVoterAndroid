package com.popstack.mvoter2015.feature.party.detail

import android.os.Bundle
import android.view.LayoutInflater
import androidx.core.os.bundleOf
import androidx.core.view.isVisible
import androidx.lifecycle.Observer
import androidx.recyclerview.widget.LinearLayoutManager
import coil.api.load
import coil.size.Scale
import com.popstack.mvoter2015.R
import com.popstack.mvoter2015.core.mvp.MvvmController
import com.popstack.mvoter2015.databinding.ControllerPartyDetailBinding
import com.popstack.mvoter2015.domain.party.model.PartyId
import com.popstack.mvoter2015.helper.asyncviewstate.AsyncViewState
import com.popstack.mvoter2015.helper.conductor.requireActivityAsAppCompatActivity
import com.popstack.mvoter2015.helper.conductor.requireContext
import com.popstack.mvoter2015.helper.intent.Intents
import com.popstack.mvoter2015.logging.HasTag
import javax.inject.Inject

class PartyDetailController(bundle: Bundle) : MvvmController<ControllerPartyDetailBinding>(bundle), HasTag {

  override val tag: String = "PartyDetailController"

  /***
   * Since we dont have factory yet
   * https://github.com/bluelinelabs/Conductor/pull/594
   */
  companion object {
    private const val ARG_PARTY_ID = "party_id"

    fun newInstance(partyId: PartyId): PartyDetailController {
      return PartyDetailController(
        bundleOf(
          ARG_PARTY_ID to partyId.value
        )
      )
    }
  }

  // Inject the factory generated by AssistedInject
  @Inject
  lateinit var partyDetailViewModelFactory: PartyDetailViewModel.Factory

  private val viewModel: PartyDetailViewModel by viewModels(
    PartyDetailViewModel.provideFactory(
      partyDetailViewModelFactory,
      PartyDetailViewModel.Params(
        PartyId(args.getString(ARG_PARTY_ID)!!)
      )
    )
  )

  private val timelineAdapter by lazy {
    PartyTimelineRecyclerViewAdapter()
  }

  override val bindingInflater: (LayoutInflater) -> ControllerPartyDetailBinding =
    ControllerPartyDetailBinding::inflate

  override fun onBindView(savedViewState: Bundle?) {
    super.onBindView(savedViewState)

    binding.rvTimeline.apply {
      adapter = timelineAdapter
      layoutManager = LinearLayoutManager(requireContext())
    }
    requireActivityAsAppCompatActivity().setSupportActionBar(binding.toolBar)
    requireActivityAsAppCompatActivity().supportActionBar?.title = ""

    viewModel.viewItemLiveData.observe(this, Observer(::observeViewItem))
    binding.btnRetry.setOnClickListener {
      viewModel.loadData()
    }

    if (savedViewState == null) {
      viewModel.loadData()
    }
  }

  private fun observeViewItem(viewState: AsyncViewState<PartyDetailViewItem>) {
    binding.progressBar.isVisible = viewState is AsyncViewState.Loading
    binding.layoutContent.isVisible = viewState is AsyncViewState.Success
    binding.tvErrorMessage.isVisible = viewState is AsyncViewState.Error
    binding.btnRetry.isVisible = viewState is AsyncViewState.Error

    when (viewState) {
      is AsyncViewState.Success -> {
        val viewItem = viewState.value
        binding.ivPartySeal.load(viewItem.sealImage) {
          scale(Scale.FIT)
          placeholder(R.drawable.placeholder_rect)
          crossfade(true)
        }
        binding.tvPartyName.text = viewItem.name

        binding.tvPartyNameEnglish.isVisible = viewItem.nameEnglish != null
        viewItem.nameEnglish?.let {
          binding.tvPartyNameEnglish.text = it
        }

        binding.tvPartyNameAbbreviation.isVisible = viewItem.nameAbbreviation != null
        viewItem.nameAbbreviation?.let {
          binding.tvPartyNameAbbreviation.text = it
        }

        binding.buttonPolicy.setOnClickListener {
          Intents.viewUrl(viewItem.policy)
        }

        binding.ivPartyFlag.load(viewItem.flagImage) {
          scale(Scale.FIT)
          placeholder(R.drawable.placeholder_rect)
          crossfade(true)
        }

        binding.tvLeader.text = viewItem.leadersAndChairmen
        binding.tvMemberCount.text = viewItem.memberCount
        binding.tvHeadquarterLocation.text = viewItem.headQuarterLocation
        binding.tvContact.text = viewItem.contact
        binding.cardViewTimeline.isVisible = viewItem.timeline.isNotEmpty()
        timelineAdapter.submitList(viewItem.timeline)

      }
      is AsyncViewState.Error -> {
        val error = viewState.errorMessage
        binding.tvErrorMessage.text = error
      }
    }
  }
}